/**
 * @remix-run/testing v1.19.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var react = require('@remix-run/react');
var reactRouterDom = require('react-router-dom');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

function patchRoutesWithContext(routes, context) {
  return routes.map(route => {
    if (route.loader) {
      let loader = route.loader;
      route.loader = args => loader({
        ...args,
        context
      });
    }
    if (route.action) {
      let action = route.action;
      route.action = args => action({
        ...args,
        context
      });
    }
    if (route.children) {
      return {
        ...route,
        children: patchRoutesWithContext(route.children, context)
      };
    }
    return route;
  });
}
function createRemixStub(routes, context = {}) {
  return function RemixStub({
    initialEntries,
    initialIndex,
    hydrationData,
    remixConfigFuture
  }) {
    let routerRef = React__namespace.useRef();
    let remixContextRef = React__namespace.useRef();
    if (routerRef.current == null) {
      // update the routes to include context in the loader/action
      let patched = patchRoutesWithContext(routes, context);
      routerRef.current = reactRouterDom.createMemoryRouter(patched, {
        initialEntries,
        initialIndex,
        hydrationData
      });
    }
    if (remixContextRef.current == null) {
      remixContextRef.current = {
        future: {
          v2_dev: false,
          unstable_postcss: false,
          unstable_tailwind: false,
          v2_errorBoundary: false,
          v2_headers: false,
          v2_meta: false,
          v2_normalizeFormMethod: false,
          v2_routeConvention: false,
          ...remixConfigFuture
        },
        manifest: createManifest(routerRef.current.routes),
        routeModules: createRouteModules(routerRef.current.routes)
      };
    }
    return /*#__PURE__*/React__namespace.createElement(react.UNSAFE_RemixContext.Provider, {
      value: remixContextRef.current
    }, /*#__PURE__*/React__namespace.createElement(reactRouterDom.RouterProvider, {
      router: routerRef.current
    }));
  };
}
function createManifest(routes) {
  return {
    routes: createRouteManifest(routes),
    entry: {
      imports: [],
      module: ""
    },
    url: "",
    version: ""
  };
}
function createRouteManifest(routes, manifest, parentId) {
  return routes.reduce((manifest, route) => {
    if (route.children) {
      createRouteManifest(route.children, manifest, route.id);
    }
    manifest[route.id] = convertToEntryRoute(route, parentId);
    return manifest;
  }, manifest || {});
}
function createRouteModules(routes, routeModules) {
  return routes.reduce((modules, route) => {
    if (route.children) {
      createRouteModules(route.children, modules);
    }
    modules[route.id] = {
      CatchBoundary: undefined,
      ErrorBoundary: undefined,
      // @ts-expect-error - types are still `agnostic` here
      default: () => route.element,
      handle: route.handle,
      links: undefined,
      meta: undefined,
      shouldRevalidate: undefined
    };
    return modules;
  }, routeModules || {});
}
function convertToEntryRoute(route, parentId) {
  return {
    id: route.id,
    index: route.index,
    caseSensitive: route.caseSensitive,
    path: route.path,
    parentId,
    hasAction: !!route.action,
    hasLoader: !!route.loader,
    module: "",
    hasCatchBoundary: false,
    hasErrorBoundary: false
  };
}

exports.createRemixStub = createRemixStub;
