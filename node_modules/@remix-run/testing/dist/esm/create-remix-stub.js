/**
 * @remix-run/testing v1.19.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
import * as React from 'react';
import { UNSAFE_RemixContext } from '@remix-run/react';
import { createMemoryRouter, RouterProvider } from 'react-router-dom';

function patchRoutesWithContext(routes, context) {
  return routes.map(route => {
    if (route.loader) {
      let loader = route.loader;
      route.loader = args => loader({
        ...args,
        context
      });
    }
    if (route.action) {
      let action = route.action;
      route.action = args => action({
        ...args,
        context
      });
    }
    if (route.children) {
      return {
        ...route,
        children: patchRoutesWithContext(route.children, context)
      };
    }
    return route;
  });
}
function createRemixStub(routes, context = {}) {
  return function RemixStub({
    initialEntries,
    initialIndex,
    hydrationData,
    remixConfigFuture
  }) {
    let routerRef = React.useRef();
    let remixContextRef = React.useRef();
    if (routerRef.current == null) {
      // update the routes to include context in the loader/action
      let patched = patchRoutesWithContext(routes, context);
      routerRef.current = createMemoryRouter(patched, {
        initialEntries,
        initialIndex,
        hydrationData
      });
    }
    if (remixContextRef.current == null) {
      remixContextRef.current = {
        future: {
          v2_dev: false,
          unstable_postcss: false,
          unstable_tailwind: false,
          v2_errorBoundary: false,
          v2_headers: false,
          v2_meta: false,
          v2_normalizeFormMethod: false,
          v2_routeConvention: false,
          ...remixConfigFuture
        },
        manifest: createManifest(routerRef.current.routes),
        routeModules: createRouteModules(routerRef.current.routes)
      };
    }
    return /*#__PURE__*/React.createElement(UNSAFE_RemixContext.Provider, {
      value: remixContextRef.current
    }, /*#__PURE__*/React.createElement(RouterProvider, {
      router: routerRef.current
    }));
  };
}
function createManifest(routes) {
  return {
    routes: createRouteManifest(routes),
    entry: {
      imports: [],
      module: ""
    },
    url: "",
    version: ""
  };
}
function createRouteManifest(routes, manifest, parentId) {
  return routes.reduce((manifest, route) => {
    if (route.children) {
      createRouteManifest(route.children, manifest, route.id);
    }
    manifest[route.id] = convertToEntryRoute(route, parentId);
    return manifest;
  }, manifest || {});
}
function createRouteModules(routes, routeModules) {
  return routes.reduce((modules, route) => {
    if (route.children) {
      createRouteModules(route.children, modules);
    }
    modules[route.id] = {
      CatchBoundary: undefined,
      ErrorBoundary: undefined,
      // @ts-expect-error - types are still `agnostic` here
      default: () => route.element,
      handle: route.handle,
      links: undefined,
      meta: undefined,
      shouldRevalidate: undefined
    };
    return modules;
  }, routeModules || {});
}
function convertToEntryRoute(route, parentId) {
  return {
    id: route.id,
    index: route.index,
    caseSensitive: route.caseSensitive,
    path: route.path,
    parentId,
    hasAction: !!route.action,
    hasLoader: !!route.loader,
    module: "",
    hasCatchBoundary: false,
    hasErrorBoundary: false
  };
}

export { createRemixStub };
