{
  "version": 3,
  "sources": ["../../../node_modules/@radix-ui/react-dismissable-layer/dist/packages/react/dismissable-layer/src/index.ts", "../../../node_modules/@radix-ui/react-dismissable-layer/dist/packages/react/dismissable-layer/src/DismissableLayer.tsx", "../../../node_modules/@radix-ui/react-focus-scope/dist/packages/react/focus-scope/src/index.ts", "../../../node_modules/@radix-ui/react-focus-scope/dist/packages/react/focus-scope/src/FocusScope.tsx", "../../../node_modules/@radix-ui/react-portal/dist/packages/react/portal/src/index.ts", "../../../node_modules/@radix-ui/react-portal/dist/packages/react/portal/src/Portal.tsx", "../../../node_modules/@radix-ui/react-presence/dist/packages/react/presence/src/index.ts", "../../../node_modules/@radix-ui/react-presence/dist/packages/react/presence/src/Presence.tsx", "../../../node_modules/@radix-ui/react-presence/dist/packages/react/presence/src/useStateMachine.tsx"],
  "sourcesContent": ["export {\n  DismissableLayer,\n  DismissableLayerBranch,\n  //\n  Root,\n  Branch,\n} from './DismissableLayer';\nexport type { DismissableLayerProps } from './DismissableLayer';\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useEscapeKeydown } from '@radix-ui/react-use-escape-keydown';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayer\n * -----------------------------------------------------------------------------------------------*/\n\nconst DISMISSABLE_LAYER_NAME = 'DismissableLayer';\nconst CONTEXT_UPDATE = 'dismissableLayer.update';\nconst POINTER_DOWN_OUTSIDE = 'dismissableLayer.pointerDownOutside';\nconst FOCUS_OUTSIDE = 'dismissableLayer.focusOutside';\n\nlet originalBodyPointerEvents: string;\n\nconst DismissableLayerContext = React.createContext({\n  layers: new Set<DismissableLayerElement>(),\n  layersWithOutsidePointerEventsDisabled: new Set<DismissableLayerElement>(),\n  branches: new Set<DismissableLayerBranchElement>(),\n});\n\ntype DismissableLayerElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface DismissableLayerProps extends PrimitiveDivProps {\n  /**\n   * When `true`, hover/focus/click interactions will be disabled on elements outside\n   * the `DismissableLayer`. Users will need to click twice on outside elements to\n   * interact with them: once to close the `DismissableLayer`, and again to trigger the element.\n   */\n  disableOutsidePointerEvents?: boolean;\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\n  /**\n   * Event handler called when the a `pointerdown` event happens outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void;\n  /**\n   * Event handler called when the focus moves outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onFocusOutside?: (event: FocusOutsideEvent) => void;\n  /**\n   * Event handler called when an interaction happens outside the `DismissableLayer`.\n   * Specifically, when a `pointerdown` event happens outside or focus moves outside of it.\n   * Can be prevented.\n   */\n  onInteractOutside?: (event: PointerDownOutsideEvent | FocusOutsideEvent) => void;\n  /**\n   * Handler called when the `DismissableLayer` should be dismissed\n   */\n  onDismiss?: () => void;\n}\n\nconst DismissableLayer = React.forwardRef<DismissableLayerElement, DismissableLayerProps>(\n  (props, forwardedRef) => {\n    const {\n      disableOutsidePointerEvents = false,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      ...layerProps\n    } = props;\n    const context = React.useContext(DismissableLayerContext);\n    const [node, setNode] = React.useState<DismissableLayerElement | null>(null);\n    const ownerDocument = node?.ownerDocument ?? globalThis?.document;\n    const [, force] = React.useState({});\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const layers = Array.from(context.layers);\n    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1); // prettier-ignore\n    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled); // prettier-ignore\n    const index = node ? layers.indexOf(node) : -1;\n    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;\n    const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;\n\n    const pointerDownOutside = usePointerDownOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;\n      onPointerDownOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    }, ownerDocument);\n\n    const focusOutside = useFocusOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (isFocusInBranch) return;\n      onFocusOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    }, ownerDocument);\n\n    useEscapeKeydown((event) => {\n      const isHighestLayer = index === context.layers.size - 1;\n      if (!isHighestLayer) return;\n      onEscapeKeyDown?.(event);\n      if (!event.defaultPrevented && onDismiss) {\n        event.preventDefault();\n        onDismiss();\n      }\n    }, ownerDocument);\n\n    React.useEffect(() => {\n      if (!node) return;\n      if (disableOutsidePointerEvents) {\n        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {\n          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;\n          ownerDocument.body.style.pointerEvents = 'none';\n        }\n        context.layersWithOutsidePointerEventsDisabled.add(node);\n      }\n      context.layers.add(node);\n      dispatchUpdate();\n      return () => {\n        if (\n          disableOutsidePointerEvents &&\n          context.layersWithOutsidePointerEventsDisabled.size === 1\n        ) {\n          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;\n        }\n      };\n    }, [node, ownerDocument, disableOutsidePointerEvents, context]);\n\n    /**\n     * We purposefully prevent combining this effect with the `disableOutsidePointerEvents` effect\n     * because a change to `disableOutsidePointerEvents` would remove this layer from the stack\n     * and add it to the end again so the layering order wouldn't be _creation order_.\n     * We only want them to be removed from context stacks when unmounted.\n     */\n    React.useEffect(() => {\n      return () => {\n        if (!node) return;\n        context.layers.delete(node);\n        context.layersWithOutsidePointerEventsDisabled.delete(node);\n        dispatchUpdate();\n      };\n    }, [node, context]);\n\n    React.useEffect(() => {\n      const handleUpdate = () => force({});\n      document.addEventListener(CONTEXT_UPDATE, handleUpdate);\n      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);\n    }, []);\n\n    return (\n      <Primitive.div\n        {...layerProps}\n        ref={composedRefs}\n        style={{\n          pointerEvents: isBodyPointerEventsDisabled\n            ? isPointerEventsEnabled\n              ? 'auto'\n              : 'none'\n            : undefined,\n          ...props.style,\n        }}\n        onFocusCapture={composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture)}\n        onBlurCapture={composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture)}\n        onPointerDownCapture={composeEventHandlers(\n          props.onPointerDownCapture,\n          pointerDownOutside.onPointerDownCapture\n        )}\n      />\n    );\n  }\n);\n\nDismissableLayer.displayName = DISMISSABLE_LAYER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayerBranch\n * -----------------------------------------------------------------------------------------------*/\n\nconst BRANCH_NAME = 'DismissableLayerBranch';\n\ntype DismissableLayerBranchElement = React.ElementRef<typeof Primitive.div>;\ninterface DismissableLayerBranchProps extends PrimitiveDivProps {}\n\nconst DismissableLayerBranch = React.forwardRef<\n  DismissableLayerBranchElement,\n  DismissableLayerBranchProps\n>((props, forwardedRef) => {\n  const context = React.useContext(DismissableLayerContext);\n  const ref = React.useRef<DismissableLayerBranchElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      context.branches.add(node);\n      return () => {\n        context.branches.delete(node);\n      };\n    }\n  }, [context.branches]);\n\n  return <Primitive.div {...props} ref={composedRefs} />;\n});\n\nDismissableLayerBranch.displayName = BRANCH_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype PointerDownOutsideEvent = CustomEvent<{ originalEvent: PointerEvent }>;\ntype FocusOutsideEvent = CustomEvent<{ originalEvent: FocusEvent }>;\n\n/**\n * Listens for `pointerdown` outside a react subtree. We use `pointerdown` rather than `pointerup`\n * to mimic layer dismissing behaviour present in OS.\n * Returns props to pass to the node we want to check for outside events.\n */\nfunction usePointerDownOutside(\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void,\n  ownerDocument: Document = globalThis?.document\n) {\n  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside) as EventListener;\n  const isPointerInsideReactTreeRef = React.useRef(false);\n  const handleClickRef = React.useRef(() => {});\n\n  React.useEffect(() => {\n    const handlePointerDown = (event: PointerEvent) => {\n      if (event.target && !isPointerInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n\n        function handleAndDispatchPointerDownOutsideEvent() {\n          handleAndDispatchCustomEvent(\n            POINTER_DOWN_OUTSIDE,\n            handlePointerDownOutside,\n            eventDetail,\n            { discrete: true }\n          );\n        }\n\n        /**\n         * On touch devices, we need to wait for a click event because browsers implement\n         * a ~350ms delay between the time the user stops touching the display and when the\n         * browser executres events. We need to ensure we don't reactivate pointer-events within\n         * this timeframe otherwise the browser may execute events that should have been prevented.\n         *\n         * Additionally, this also lets us deal automatically with cancellations when a click event\n         * isn't raised because the page was considered scrolled/drag-scrolled, long-pressed, etc.\n         *\n         * This is why we also continuously remove the previous listener, because we cannot be\n         * certain that it was raised, and therefore cleaned-up.\n         */\n        if (event.pointerType === 'touch') {\n          ownerDocument.removeEventListener('click', handleClickRef.current);\n          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;\n          ownerDocument.addEventListener('click', handleClickRef.current, { once: true });\n        } else {\n          handleAndDispatchPointerDownOutsideEvent();\n        }\n      } else {\n        // We need to remove the event listener in case the outside click has been canceled.\n        // See: https://github.com/radix-ui/primitives/issues/2171\n        ownerDocument.removeEventListener('click', handleClickRef.current);\n      }\n      isPointerInsideReactTreeRef.current = false;\n    };\n    /**\n     * if this hook executes in a component that mounts via a `pointerdown` event, the event\n     * would bubble up to the document and trigger a `pointerDownOutside` event. We avoid\n     * this by delaying the event listener registration on the document.\n     * This is not React specific, but rather how the DOM works, ie:\n     * ```\n     * button.addEventListener('pointerdown', () => {\n     *   console.log('I will log');\n     *   document.addEventListener('pointerdown', () => {\n     *     console.log('I will also log');\n     *   })\n     * });\n     */\n    const timerId = window.setTimeout(() => {\n      ownerDocument.addEventListener('pointerdown', handlePointerDown);\n    }, 0);\n    return () => {\n      window.clearTimeout(timerId);\n      ownerDocument.removeEventListener('pointerdown', handlePointerDown);\n      ownerDocument.removeEventListener('click', handleClickRef.current);\n    };\n  }, [ownerDocument, handlePointerDownOutside]);\n\n  return {\n    // ensures we check React component tree (not just DOM tree)\n    onPointerDownCapture: () => (isPointerInsideReactTreeRef.current = true),\n  };\n}\n\n/**\n * Listens for when focus happens outside a react subtree.\n * Returns props to pass to the root (node) of the subtree we want to check.\n */\nfunction useFocusOutside(\n  onFocusOutside?: (event: FocusOutsideEvent) => void,\n  ownerDocument: Document = globalThis?.document\n) {\n  const handleFocusOutside = useCallbackRef(onFocusOutside) as EventListener;\n  const isFocusInsideReactTreeRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const handleFocus = (event: FocusEvent) => {\n      if (event.target && !isFocusInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {\n          discrete: false,\n        });\n      }\n    };\n    ownerDocument.addEventListener('focusin', handleFocus);\n    return () => ownerDocument.removeEventListener('focusin', handleFocus);\n  }, [ownerDocument, handleFocusOutside]);\n\n  return {\n    onFocusCapture: () => (isFocusInsideReactTreeRef.current = true),\n    onBlurCapture: () => (isFocusInsideReactTreeRef.current = false),\n  };\n}\n\nfunction dispatchUpdate() {\n  const event = new CustomEvent(CONTEXT_UPDATE);\n  document.dispatchEvent(event);\n}\n\nfunction handleAndDispatchCustomEvent<E extends CustomEvent, OriginalEvent extends Event>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: OriginalEvent } & (E extends CustomEvent<infer D> ? D : never),\n  { discrete }: { discrete: boolean }\n) {\n  const target = detail.originalEvent.target;\n  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });\n  if (handler) target.addEventListener(name, handler as EventListener, { once: true });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(target, event);\n  } else {\n    target.dispatchEvent(event);\n  }\n}\n\nconst Root = DismissableLayer;\nconst Branch = DismissableLayerBranch;\n\nexport {\n  DismissableLayer,\n  DismissableLayerBranch,\n  //\n  Root,\n  Branch,\n};\nexport type { DismissableLayerProps };\n", "export {\n  FocusScope,\n  //\n  Root,\n} from './FocusScope';\nexport type { FocusScopeProps } from './FocusScope';\n", "import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\nconst AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\ntype FocusableTarget = HTMLElement | { focus(): void };\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_SCOPE_NAME = 'FocusScope';\n\ntype FocusScopeElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface FocusScopeProps extends PrimitiveDivProps {\n  /**\n   * When `true`, tabbing from last item will focus first tabbable\n   * and shift+tab from first item will focus last tababble.\n   * @defaultValue false\n   */\n  loop?: boolean;\n\n  /**\n   * When `true`, focus cannot escape the focus scope via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapped?: boolean;\n\n  /**\n   * Event handler called when auto-focusing on mount.\n   * Can be prevented.\n   */\n  onMountAutoFocus?: (event: Event) => void;\n\n  /**\n   * Event handler called when auto-focusing on unmount.\n   * Can be prevented.\n   */\n  onUnmountAutoFocus?: (event: Event) => void;\n}\n\nconst FocusScope = React.forwardRef<FocusScopeElement, FocusScopeProps>((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState<HTMLElement | null>(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef<HTMLElement | null>(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));\n\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    },\n  }).current;\n\n  // Takes care of trapping focus if focus is moved outside programmatically for example\n  React.useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const target = event.target as HTMLElement | null;\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      function handleFocusOut(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const relatedTarget = event.relatedTarget as HTMLElement | null;\n\n        // A `focusout` event with a `null` `relatedTarget` will happen in at least two cases:\n        //\n        // 1. When the user switches app/tabs/windows/the browser itself loses focus.\n        // 2. In Google Chrome, when the focused element is removed from the DOM.\n        //\n        // We let the browser do its thing here because:\n        //\n        // 1. The browser already keeps a memory of what's focused for when the page gets refocused.\n        // 2. In Google Chrome, if we try to focus the deleted focused element (as per below), it\n        //    throws the CPU to 100%, so we avoid doing anything for this reason here too.\n        if (relatedTarget === null) return;\n\n        // If the focus has moved to an actual legitimate element (`relatedTarget !== null`)\n        // that is outside the container, we move focus to the last valid focused element inside.\n        if (!container.contains(relatedTarget)) {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      // When the focused element gets removed from the DOM, browsers move focus\n      // back to the document.body. In this case, we move focus to the container\n      // to keep focus trapped correctly.\n      function handleMutations(mutations: MutationRecord[]) {\n        const focusedElement = document.activeElement as HTMLElement | null;\n        if (focusedElement !== document.body) return;\n        for (const mutation of mutations) {\n          if (mutation.removedNodes.length > 0) focus(container);\n        }\n      }\n\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      const mutationObserver = new MutationObserver(handleMutations);\n      if (container) mutationObserver.observe(container, { childList: true, subtree: true });\n\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n        mutationObserver.disconnect();\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement as HTMLElement | null;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n\n        // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, { select: true });\n          }\n          // we need to remove the listener after we `dispatchEvent`\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n\n  // Takes care of looping focus (when tabbing whilst at the edges)\n  const handleKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      if (!loop && !trapped) return;\n      if (focusScope.paused) return;\n\n      const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n      const focusedElement = document.activeElement as HTMLElement | null;\n\n      if (isTabKey && focusedElement) {\n        const container = event.currentTarget as HTMLElement;\n        const [first, last] = getTabbableEdges(container);\n        const hasTabbableElementsInside = first && last;\n\n        // we can only wrap focus if we have tabbable edges\n        if (!hasTabbableElementsInside) {\n          if (focusedElement === container) event.preventDefault();\n        } else {\n          if (!event.shiftKey && focusedElement === last) {\n            event.preventDefault();\n            if (loop) focus(first, { select: true });\n          } else if (event.shiftKey && focusedElement === first) {\n            event.preventDefault();\n            if (loop) focus(last, { select: true });\n          }\n        }\n      }\n    },\n    [loop, trapped, focusScope.paused]\n  );\n\n  return (\n    <Primitive.div tabIndex={-1} {...scopeProps} ref={composedRefs} onKeyDown={handleKeyDown} />\n  );\n});\n\nFocusScope.displayName = FOCUS_SCOPE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Attempts focusing the first element in a list of candidates.\n * Stops when focus has actually moved.\n */\nfunction focusFirst(candidates: HTMLElement[], { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, { select });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nfunction getTabbableEdges(container: HTMLElement) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last] as const;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nfunction findVisible(elements: HTMLElement[], container: HTMLElement) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!isHidden(element, { upTo: container })) return element;\n  }\n}\n\nfunction isHidden(node: HTMLElement, { upTo }: { upTo?: HTMLElement }) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement as HTMLElement;\n  }\n  return false;\n}\n\nfunction isSelectableInput(element: any): element is FocusableTarget & { select: () => void } {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\n\nfunction focus(element?: FocusableTarget | null, { select = false } = {}) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({ preventScroll: true });\n    // only select if its not the same element, it supports selection and we need to select\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)\n      element.select();\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\n\ntype FocusScopeAPI = { paused: boolean; pause(): void; resume(): void };\nconst focusScopesStack = createFocusScopesStack();\n\nfunction createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */\n  let stack: FocusScopeAPI[] = [];\n\n  return {\n    add(focusScope: FocusScopeAPI) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n\n    remove(focusScope: FocusScopeAPI) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    },\n  };\n}\n\nfunction arrayRemove<T>(array: T[], item: T) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\n\nfunction removeLinks(items: HTMLElement[]) {\n  return items.filter((item) => item.tagName !== 'A');\n}\n\nconst Root = FocusScope;\n\nexport {\n  FocusScope,\n  //\n  Root,\n};\nexport type { FocusScopeProps };\n", "export {\n  Portal,\n  //\n  Root,\n} from './Portal';\nexport type { PortalProps } from './Portal';\n", "import * as React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n * Portal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'Portal';\n\ntype PortalElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface PortalProps extends PrimitiveDivProps {\n  /**\n   * An optional container where the portaled content should be appended.\n   */\n  container?: HTMLElement | null;\n}\n\nconst Portal = React.forwardRef<PortalElement, PortalProps>((props, forwardedRef) => {\n  const { container = globalThis?.document?.body, ...portalProps } = props;\n  return container\n    ? ReactDOM.createPortal(<Primitive.div {...portalProps} ref={forwardedRef} />, container)\n    : null;\n});\n\nPortal.displayName = PORTAL_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Portal;\n\nexport {\n  Portal,\n  //\n  Root,\n};\nexport type { PortalProps };\n", "export { Presence } from './Presence';\nexport type { PresenceProps } from './Presence';\n", "import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useStateMachine } from './useStateMachine';\n\ninterface PresenceProps {\n  children: React.ReactElement | ((props: { present: boolean }) => React.ReactElement);\n  present: boolean;\n}\n\nconst Presence: React.FC<PresenceProps> = (props) => {\n  const { present, children } = props;\n  const presence = usePresence(present);\n\n  const child = (\n    typeof children === 'function'\n      ? children({ present: presence.isPresent })\n      : React.Children.only(children)\n  ) as React.ReactElement;\n\n  const ref = useComposedRefs(presence.ref, (child as any).ref);\n  const forceMount = typeof children === 'function';\n  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;\n};\n\nPresence.displayName = 'Presence';\n\n/* -------------------------------------------------------------------------------------------------\n * usePresence\n * -----------------------------------------------------------------------------------------------*/\n\nfunction usePresence(present: boolean) {\n  const [node, setNode] = React.useState<HTMLElement>();\n  const stylesRef = React.useRef<CSSStyleDeclaration>({} as any);\n  const prevPresentRef = React.useRef(present);\n  const prevAnimationNameRef = React.useRef<string>('none');\n  const initialState = present ? 'mounted' : 'unmounted';\n  const [state, send] = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: 'unmounted',\n      ANIMATION_OUT: 'unmountSuspended',\n    },\n    unmountSuspended: {\n      MOUNT: 'mounted',\n      ANIMATION_END: 'unmounted',\n    },\n    unmounted: {\n      MOUNT: 'mounted',\n    },\n  });\n\n  React.useEffect(() => {\n    const currentAnimationName = getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === 'mounted' ? currentAnimationName : 'none';\n  }, [state]);\n\n  useLayoutEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n\n      if (present) {\n        send('MOUNT');\n      } else if (currentAnimationName === 'none' || styles?.display === 'none') {\n        // If there is no exit animation or the element is hidden, animations won't run\n        // so we unmount instantly\n        send('UNMOUNT');\n      } else {\n        /**\n         * When `present` changes to `false`, we check changes to animation-name to\n         * determine whether an animation has started. We chose this approach (reading\n         * computed styles) because there is no `animationrun` event and `animationstart`\n         * fires after `animation-delay` has expired which would be too late.\n         */\n        const isAnimating = prevAnimationName !== currentAnimationName;\n\n        if (wasPresent && isAnimating) {\n          send('ANIMATION_OUT');\n        } else {\n          send('UNMOUNT');\n        }\n      }\n\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n\n  useLayoutEffect(() => {\n    if (node) {\n      /**\n       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n       * make sure we only trigger ANIMATION_END for the currently active animation.\n       */\n      const handleAnimationEnd = (event: AnimationEvent) => {\n        const currentAnimationName = getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n        if (event.target === node && isCurrentAnimation) {\n          // With React 18 concurrency this update is applied\n          // a frame after the animation ends, creating a flash of visible content.\n          // By manually flushing we ensure they sync within a frame, removing the flash.\n          ReactDOM.flushSync(() => send('ANIMATION_END'));\n        }\n      };\n      const handleAnimationStart = (event: AnimationEvent) => {\n        if (event.target === node) {\n          // if animation occurred, store its name as the previous animation.\n          prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n        }\n      };\n      node.addEventListener('animationstart', handleAnimationStart);\n      node.addEventListener('animationcancel', handleAnimationEnd);\n      node.addEventListener('animationend', handleAnimationEnd);\n      return () => {\n        node.removeEventListener('animationstart', handleAnimationStart);\n        node.removeEventListener('animationcancel', handleAnimationEnd);\n        node.removeEventListener('animationend', handleAnimationEnd);\n      };\n    } else {\n      // Transition to the unmounted state if the node is removed prematurely.\n      // We avoid doing so during cleanup as the node may change but still exist.\n      send('ANIMATION_END');\n    }\n  }, [node, send]);\n\n  return {\n    isPresent: ['mounted', 'unmountSuspended'].includes(state),\n    ref: React.useCallback((node: HTMLElement) => {\n      if (node) stylesRef.current = getComputedStyle(node);\n      setNode(node);\n    }, []),\n  };\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getAnimationName(styles?: CSSStyleDeclaration) {\n  return styles?.animationName || 'none';\n}\n\nexport { Presence };\nexport type { PresenceProps };\n", "import * as React from 'react';\n\ntype Machine<S> = { [k: string]: { [k: string]: S } };\ntype MachineState<T> = keyof T;\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>;\n\n// 🤯 https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any\n  ? R\n  : never;\n\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>\n) {\n  return React.useReducer((state: MachineState<M>, event: MachineEvent<M>): MachineState<M> => {\n    const nextState = (machine[state] as any)[event];\n    return nextState ?? state;\n  }, initialState);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;ACcA,IAAMA,uCAAiB;AACvB,IAAMC,6CAAuB;AAC7B,IAAMC,sCAAgB;AAEtB,IAAIC;AAEJ,IAAMC,gDAA0BC,iCAAAA,eAAoB;EAClDC,QAAQ,oBAAIC,IAAJ;EACRC,wCAAwC,oBAAID,IAAJ;EACxCE,UAAU,oBAAIF,IAAJ;CAHoB;AA0ChC,IAAMG,4CAAmBL,iCAAAA,YACvB,CAACM,OAAOC,iBAAiB;AAAA,MAAA;AACvB,QAAM,EAAA,8BAC0B,OAD1B,iBAAA,sBAAA,gBAAA,mBAAA,WAOJ,GAAGC,WAAH,IACEF;AACJ,QAAMG,cAAUT,aAAAA,YAAiBD,6CAAjB;AAChB,QAAM,CAACW,OAAMC,OAAP,QAAkBX,aAAAA,UAA+C,IAA/C;AACxB,QAAMY,iBAAa,sBAAGF,UAAH,QAAGA,UAAH,SAAA,SAAGA,MAAME,mBAAT,QAAA,wBAAA,SAAA,sBAA0BC,eAA1B,QAA0BA,eAA1B,SAAA,SAA0BA,WAAYC;AACzD,QAAM,CAAA,EAAGC,KAAH,QAAYf,aAAAA,UAAe,CAAA,CAAf;AAClB,QAAMgB,eAAeC;IAAgBV;IAAeG,CAAAA,SAASC,QAAQD,IAAD;EAAhC;AACpC,QAAMT,SAASiB,MAAMC,KAAKV,QAAQR,MAAnB;AACf,QAAM,CAACmB,4CAAD,IAAiD;OAAIX,QAAQN;IAAwCkB,MAAM,EAA1D;AACvD,QAAMC,oDAAoDrB,OAAOsB,QAAQH,4CAAf;AAC1D,QAAMI,QAAQd,QAAOT,OAAOsB,QAAQb,KAAf,IAAuB;AAC5C,QAAMe,8BAA8BhB,QAAQN,uCAAuCuB,OAAO;AAC1F,QAAMC,yBAAyBH,SAASF;AAExC,QAAMM,qBAAqBC,4CAAuBC,CAAAA,UAAU;AAC1D,UAAMC,SAASD,MAAMC;AACrB,UAAMC,wBAAwB;SAAIvB,QAAQL;MAAU6B;MAAMC,CAAAA,WAAWA,OAAOC,SAASJ,MAAhB;IAAvC;AAC9B,QAAI,CAACJ,0BAA0BK;AAAuB;AACtDI,6BAAoB,QAApBA,yBAAoB,UAApBA,qBAAuBN,KAAH;AACpBO,0BAAiB,QAAjBA,sBAAiB,UAAjBA,kBAAoBP,KAAH;AACjB,QAAI,CAACA,MAAMQ;AAAkBC,oBAAS,QAATA,cAAS,UAATA,UAAS;KACrC3B,aAP6C;AAShD,QAAM4B,eAAeC,sCAAiBX,CAAAA,UAAU;AAC9C,UAAMC,SAASD,MAAMC;AACrB,UAAMW,kBAAkB;SAAIjC,QAAQL;MAAU6B;MAAMC,CAAAA,WAAWA,OAAOC,SAASJ,MAAhB;IAAvC;AACxB,QAAIW;AAAiB;AACrBC,uBAAc,QAAdA,mBAAc,UAAdA,eAAiBb,KAAH;AACdO,0BAAiB,QAAjBA,sBAAiB,UAAjBA,kBAAoBP,KAAH;AACjB,QAAI,CAACA,MAAMQ;AAAkBC,oBAAS,QAATA,cAAS,UAATA,UAAS;KACrC3B,aAPiC;AASpCgC,4CAAkBd,CAAAA,UAAU;AAC1B,UAAMe,iBAAiBrB,UAAUf,QAAQR,OAAOyB,OAAO;AACvD,QAAI,CAACmB;AAAgB;AACrBC,wBAAe,QAAfA,oBAAe,UAAfA,gBAAkBhB,KAAH;AACf,QAAI,CAACA,MAAMQ,oBAAoBC,WAAW;AACxCT,YAAMiB,eAAN;AACAR,gBAAS;;KAEV3B,aARa;AAUhBZ,mBAAAA,WAAgB,MAAM;AACpB,QAAI,CAACU;AAAM;AACX,QAAIsC,6BAA6B;AAC/B,UAAIvC,QAAQN,uCAAuCuB,SAAS,GAAG;AAC7D5B,0DAA4Bc,cAAcqC,KAAKC,MAAMC;AACrDvC,sBAAcqC,KAAKC,MAAMC,gBAAgB;;AAE3C1C,cAAQN,uCAAuCiD,IAAI1C,KAAnD;;AAEFD,YAAQR,OAAOmD,IAAI1C,KAAnB;AACA2C,yCAAc;AACd,WAAO,MAAM;AACX,UACEL,+BACAvC,QAAQN,uCAAuCuB,SAAS;AAExDd,sBAAcqC,KAAKC,MAAMC,gBAAgBrD;;KAG5C;IAACY;IAAME;IAAeoC;IAA6BvC;GAnBtD;AA2BAT,mBAAAA,WAAgB,MAAM;AACpB,WAAO,MAAM;AACX,UAAI,CAACU;AAAM;AACXD,cAAQR,OAAOqD,OAAO5C,KAAtB;AACAD,cAAQN,uCAAuCmD,OAAO5C,KAAtD;AACA2C,2CAAc;;KAEf;IAAC3C;IAAMD;GAPV;AASAT,mBAAAA,WAAgB,MAAM;AACpB,UAAMuD,eAAe,MAAMxC,MAAM,CAAA,CAAD;AAChCD,aAAS0C,iBAAiB7D,sCAAgB4D,YAA1C;AACA,WAAO,MAAMzC,SAAS2C,oBAAoB9D,sCAAgB4D,YAA7C;KACZ,CAAA,CAJH;AAMA,SACE,iCAAAG,eAAC,0CAAU,KAAX,SAAA,CAAA,GACMlD,YAFR;IAGI,KAAKQ;IACL,OAAO;MACLmC,eAAe1B,8BACXE,yBACE,SACA,SACFgC;MACJ,GAAGrD,MAAM4C;;IAEX,gBAAgBU,0CAAqBtD,MAAMuD,gBAAgBrB,aAAaqB,cAApC;IACpC,eAAeD,0CAAqBtD,MAAMwD,eAAetB,aAAasB,aAAnC;IACnC,sBAAsBF,0CACpBtD,MAAMyD,sBACNnC,mBAAmBmC,oBAFqB;GAb5C,CAAA;CA9FmB;AAgKzB,SAASC,4CACPC,sBACAC,gBAA0BC,eAAH,QAAGA,eAAH,SAAA,SAAGA,WAAYC,UACtC;AACA,QAAMC,2BAA2BC,0CAAeL,oBAAD;AAC/C,QAAMM,kCAA8BC,aAAAA,QAAa,KAAb;AACpC,QAAMC,qBAAiBD,aAAAA,QAAa,MAAM;EAAA,CAAnB;AAEvBA,mBAAAA,WAAgB,MAAM;AACpB,UAAME,oBAAqBC,CAAAA,UAAwB;AACjD,UAAIA,MAAMC,UAAU,CAACL,4BAA4BM,SAAS;AAGxD,YAASC,2CAAT,WAAoD;AAClDC,6DACEC,4CACAX,0BACAY,aACA;YAAEC,UAAU;WAJc;;AAH9B,cAAMD,cAAc;UAAEE,eAAeR;;AAuBrC,YAAIA,MAAMS,gBAAgB,SAAS;AACjClB,wBAAcmB,oBAAoB,SAASZ,eAAeI,OAA1D;AACAJ,yBAAeI,UAAUC;AACzBZ,wBAAcoB,iBAAiB,SAASb,eAAeI,SAAS;YAAEU,MAAM;WAAxE;;AAEAT,mDAAwC;;AAK1CZ,sBAAcmB,oBAAoB,SAASZ,eAAeI,OAA1D;AAEFN,kCAA4BM,UAAU;;AAexC,UAAMW,UAAUC,OAAOC,WAAW,MAAM;AACtCxB,oBAAcoB,iBAAiB,eAAeZ,iBAA9C;OACC,CAFa;AAGhB,WAAO,MAAM;AACXe,aAAOE,aAAaH,OAApB;AACAtB,oBAAcmB,oBAAoB,eAAeX,iBAAjD;AACAR,oBAAcmB,oBAAoB,SAASZ,eAAeI,OAA1D;;KAED;IAACX;IAAeG;GA7DnB;AA+DA,SAAO;;IAELuB,sBAAsB,MAAOrB,4BAA4BM,UAAU;;;AAQvE,SAASgB,sCACPC,gBACA5B,gBAA0BC,eAAH,QAAGA,eAAH,SAAA,SAAGA,WAAYC,UACtC;AACA,QAAM2B,qBAAqBzB,0CAAewB,cAAD;AACzC,QAAME,gCAA4BxB,aAAAA,QAAa,KAAb;AAElCA,mBAAAA,WAAgB,MAAM;AACpB,UAAMyB,cAAetB,CAAAA,UAAsB;AACzC,UAAIA,MAAMC,UAAU,CAACoB,0BAA0BnB,SAAS;AACtD,cAAMI,cAAc;UAAEE,eAAeR;;AACrCI,2DAA6BmB,qCAAeH,oBAAoBd,aAAa;UAC3EC,UAAU;SADgB;;;AAKhChB,kBAAcoB,iBAAiB,WAAWW,WAA1C;AACA,WAAO,MAAM/B,cAAcmB,oBAAoB,WAAWY,WAA7C;KACZ;IAAC/B;IAAe6B;GAXnB;AAaA,SAAO;IACLI,gBAAgB,MAAOH,0BAA0BnB,UAAU;IAC3DuB,eAAe,MAAOJ,0BAA0BnB,UAAU;;;AAI9D,SAASwB,uCAAiB;AACxB,QAAM1B,QAAQ,IAAI2B,YAAYC,oCAAhB;AACdnC,WAASoC,cAAc7B,KAAvB;;AAGF,SAASI,mDACP0B,MACAC,SACAC,QACA,EAAA,SAAEzB,GACF;AACA,QAAMN,SAAS+B,OAAOxB,cAAcP;AACpC,QAAMD,QAAQ,IAAI2B,YAAYG,MAAM;IAAEG,SAAS;IAAOC,YAAY;;GAApD;AACd,MAAIH;AAAS9B,WAAOU,iBAAiBmB,MAAMC,SAA0B;MAAEnB,MAAM;KAAhE;AAEb,MAAIL;AACF4B,8CAA4BlC,QAAQD,KAAT;;AAE3BC,WAAO4B,cAAc7B,KAArB;;;;;AEpVJ,IAAMoC,2CAAqB;AAC3B,IAAMC,6CAAuB;AAC7B,IAAMC,sCAAgB;EAAEC,SAAS;EAAOC,YAAY;;AAwCpD,IAAMC,4CAAaC,kCAAAA,YAAqD,CAACC,OAAOC,iBAAiB;AAC/F,QAAM,EAAA,OACG,OADH,UAEM,OACVC,kBAAkBC,sBAClBC,oBAAoBC,wBACpB,GAAGC,WAAH,IACEN;AACJ,QAAM,CAACO,YAAWC,YAAZ,QAA4BT,cAAAA,UAAmC,IAAnC;AAClC,QAAMG,mBAAmBO,0CAAeN,oBAAD;AACvC,QAAMC,qBAAqBK,0CAAeJ,sBAAD;AACzC,QAAMK,4BAAwBX,cAAAA,QAAiC,IAAjC;AAC9B,QAAMY,eAAeC;IAAgBX;IAAeY,CAAAA,SAASL,aAAaK,IAAD;EAArC;AAEpC,QAAMC,iBAAaf,cAAAA,QAAa;IAC9BgB,QAAQ;IACRC,QAAQ;AACN,WAAKD,SAAS;;IAEhBE,SAAS;AACP,WAAKF,SAAS;;GANC,EAQhBG;AAGHnB,oBAAAA,WAAgB,MAAM;AACpB,QAAIoB,SAAS;AACX,UAASC,gBAAT,SAAuBC,OAAmB;AACxC,YAAIP,WAAWC,UAAU,CAACR;AAAW;AACrC,cAAMe,SAASD,MAAMC;AACrB,YAAIf,WAAUgB,SAASD,MAAnB;AACFZ,gCAAsBQ,UAAUI;;AAEhCE,sCAAMd,sBAAsBQ,SAAS;YAAEO,QAAQ;WAA1C;SAIAC,iBAAT,SAAwBL,OAAmB;AACzC,YAAIP,WAAWC,UAAU,CAACR;AAAW;AACrC,cAAMoB,gBAAgBN,MAAMM;AAY5B,YAAIA,kBAAkB;AAAM;AAI5B,YAAI,CAACpB,WAAUgB,SAASI,aAAnB;AACHH,sCAAMd,sBAAsBQ,SAAS;YAAEO,QAAQ;WAA1C;SAOAG,kBAAT,SAAyBC,WAA6B;AACpD,cAAMC,iBAAiBC,SAASC;AAChC,YAAIF,mBAAmBC,SAASE;AAAM;AACtC,mBAAWC,YAAYL;AACrB,cAAIK,SAASC,aAAaC,SAAS;AAAGZ,wCAAMjB,UAAD;;AAI/CwB,eAASM,iBAAiB,WAAWjB,aAArC;AACAW,eAASM,iBAAiB,YAAYX,cAAtC;AACA,YAAMY,mBAAmB,IAAIC,iBAAiBX,eAArB;AACzB,UAAIrB;AAAW+B,yBAAiBE,QAAQjC,YAAW;UAAEkC,WAAW;UAAMC,SAAS;SAAhE;AAEf,aAAO,MAAM;AACXX,iBAASY,oBAAoB,WAAWvB,aAAxC;AACAW,iBAASY,oBAAoB,YAAYjB,cAAzC;AACAY,yBAAiBM,WAAjB;;;KAGH;IAACzB;IAASZ;IAAWO,WAAWC;GAzDnC;AA2DAhB,oBAAAA,WAAgB,MAAM;AACpB,QAAIQ,YAAW;AACbsC,6CAAiBC,IAAIhC,UAArB;AACA,YAAMiC,2BAA2BhB,SAASC;AAC1C,YAAMgB,sBAAsBzC,WAAUgB,SAASwB,wBAAnB;AAE5B,UAAI,CAACC,qBAAqB;AACxB,cAAMC,aAAa,IAAIC,YAAYC,0CAAoBC,mCAApC;AACnB7C,mBAAU8B,iBAAiBc,0CAAoBjD,gBAA/C;AACAK,mBAAU8C,cAAcJ,UAAxB;AACA,YAAI,CAACA,WAAWK,kBAAkB;AAChCC,2CAAWC,kCAAYC,4CAAsBlD,UAAD,CAAtB,GAAoC;YAAEkB,QAAQ;WAA1D;AACV,cAAIM,SAASC,kBAAkBe;AAC7BvB,wCAAMjB,UAAD;;;AAKX,aAAO,MAAM;AACXA,mBAAUoC,oBAAoBQ,0CAAoBjD,gBAAlD;AAKAwD,mBAAW,MAAM;AACf,gBAAMC,eAAe,IAAIT,YAAYU,4CAAsBR,mCAAtC;AACrB7C,qBAAU8B,iBAAiBuB,4CAAsBxD,kBAAjD;AACAG,qBAAU8C,cAAcM,YAAxB;AACA,cAAI,CAACA,aAAaL;AAChB9B,wCAAMuB,6BAAD,QAACA,6BAAD,SAACA,2BAA4BhB,SAASE,MAAM;cAAER,QAAQ;aAAtD;AAGPlB,qBAAUoC,oBAAoBiB,4CAAsBxD,kBAApD;AAEAyC,iDAAiBgB,OAAO/C,UAAxB;WACC,CAXO;;;KAcb;IAACP;IAAWL;IAAkBE;IAAoBU;GAtCrD;AAyCA,QAAMgD,oBAAgB/D,cAAAA,aACnBsB,CAAAA,UAA+B;AAC9B,QAAI,CAAC0C,QAAQ,CAAC5C;AAAS;AACvB,QAAIL,WAAWC;AAAQ;AAEvB,UAAMiD,WAAW3C,MAAM4C,QAAQ,SAAS,CAAC5C,MAAM6C,UAAU,CAAC7C,MAAM8C,WAAW,CAAC9C,MAAM+C;AAClF,UAAMtC,iBAAiBC,SAASC;AAEhC,QAAIgC,YAAYlC,gBAAgB;AAC9B,YAAMvB,YAAYc,MAAMgD;AACxB,YAAM,CAACC,OAAOC,IAAR,IAAgBC,uCAAiBjE,SAAD;AACtC,YAAMkE,4BAA4BH,SAASC;AAG3C,UAAI,CAACE,2BACH;AAAA,YAAI3C,mBAAmBvB;AAAWc,gBAAMqD,eAAN;aAC7B;AACL,YAAI,CAACrD,MAAMsD,YAAY7C,mBAAmByC,MAAM;AAC9ClD,gBAAMqD,eAAN;AACA,cAAIX;AAAMvC,wCAAM8C,OAAO;cAAE7C,QAAQ;aAAlB;mBACNJ,MAAMsD,YAAY7C,mBAAmBwC,OAAO;AACrDjD,gBAAMqD,eAAN;AACA,cAAIX;AAAMvC,wCAAM+C,MAAM;cAAE9C,QAAQ;aAAjB;;;;KAKvB;IAACsC;IAAM5C;IAASL,WAAWC;GA3BP;AA8BtB,SACE,kCAAA6D,eAAC,0CAAU,KADb,SAAA;IACiB,UAAU;KAAQtE,YAAjC;IAA6C,KAAKK;IAAc,WAAWmD;GAA3E,CAAA;CA5Je;AA0KnB,SAASe,iCAAWC,YAA2B,EAAA,SAAW,MAATC,IAAmB,CAAA,GAAI;AACtE,QAAMC,2BAA2BC,SAASC;AAC1C,aAAWC,aAAaL,YAAY;AAClCM,gCAAMD,WAAW;;KAAZ;AACL,QAAIF,SAASC,kBAAkBF;AAA0B;;;AAO7D,SAASK,uCAAiBC,WAAwB;AAChD,QAAMR,aAAaS,4CAAsBD,SAAD;AACxC,QAAME,QAAQC,kCAAYX,YAAYQ,SAAb;AACzB,QAAMI,OAAOD,kCAAYX,WAAWa,QAAX,GAAsBL,SAAvB;AACxB,SAAO;IAACE;IAAOE;;;AAajB,SAASH,4CAAsBD,WAAwB;AACrD,QAAMM,QAAuB,CAAA;AAC7B,QAAMC,SAASZ,SAASa,iBAAiBR,WAAWS,WAAWC,cAAc;IAC3EC,YAAaC,CAAAA,SAAc;AACzB,YAAMC,gBAAgBD,KAAKE,YAAY,WAAWF,KAAKG,SAAS;AAChE,UAAIH,KAAKI,YAAYJ,KAAKK,UAAUJ;AAAe,eAAOJ,WAAWS;AAIrE,aAAON,KAAKO,YAAY,IAAIV,WAAWW,gBAAgBX,WAAWS;;GAPvD;AAUf,SAAOX,OAAOc,SAAP;AAAmBf,UAAMgB,KAAKf,OAAOgB,WAAlB;AAG1B,SAAOjB;;AAOT,SAASH,kCAAYqB,UAAyBxB,WAAwB;AACpE,aAAWyB,WAAWD,UAAU;AAE9B,QAAI,CAACE,+BAASD,SAAS;MAAEE,MAAM3B;KAAlB;AAAgC,aAAOyB;;;AAIxD,SAASC,+BAASd,MAAmB,EAAA,KAAEe,GAAgC;AACrE,MAAIC,iBAAiBhB,IAAD,EAAOiB,eAAe;AAAU,WAAO;AAC3D,SAAOjB,MAAM;AAEX,QAAIe,SAASG,UAAalB,SAASe;AAAM,aAAO;AAChD,QAAIC,iBAAiBhB,IAAD,EAAOmB,YAAY;AAAQ,aAAO;AACtDnB,WAAOA,KAAKoB;;AAEd,SAAO;;AAGT,SAASC,wCAAkBR,SAAmE;AAC5F,SAAOA,mBAAmBS,oBAAoB,YAAYT;;AAG5D,SAAS3B,4BAAM2B,SAAkC,EAAA,SAAW,MAAThC,IAAmB,CAAA,GAAI;AAExE,MAAIgC,WAAWA,QAAQ3B,OAAO;AAC5B,UAAMJ,2BAA2BC,SAASC;AAE1C6B,YAAQ3B,MAAM;MAAEqC,eAAe;KAA/B;AAEA,QAAIV,YAAY/B,4BAA4BuC,wCAAkBR,OAAD,KAAahC;AACxEgC,cAAQhC,OAAR;;;AASN,IAAM2C,yCAAmBC,6CAAsB;AAE/C,SAASA,+CAAyB;AAEhC,MAAIC,QAAyB,CAAA;AAE7B,SAAO;IACLC,IAAIC,YAA2B;AAE7B,YAAMC,mBAAmBH,MAAM,CAAD;AAC9B,UAAIE,eAAeC;AACjBA,6BAAgB,QAAhBA,qBAAgB,UAAhBA,iBAAkBC,MAAlB;AAGFJ,cAAQK,kCAAYL,OAAOE,UAAR;AACnBF,YAAMM,QAAQJ,UAAd;;IAGFK,OAAOL,YAA2B;AAAA,UAAA;AAChCF,cAAQK,kCAAYL,OAAOE,UAAR;AACnB,OAAA,UAAAF,MAAM,CAAD,OAAL,QAAA,YAAA,UAAA,QAAUQ,OAAV;;;;AAKN,SAASH,kCAAeI,OAAYC,MAAS;AAC3C,QAAMC,eAAe;OAAIF;;AACzB,QAAMG,QAAQD,aAAaE,QAAQH,IAArB;AACd,MAAIE,UAAU;AACZD,iBAAaG,OAAOF,OAAO,CAA3B;AAEF,SAAOD;;AAGT,SAASI,kCAAYC,OAAsB;AACzC,SAAOA,MAAMC;IAAQP,CAAAA,SAASA,KAAKlC,YAAY;EAAxC;;;;;;AElUT,IAAM0C,4CAASC,kCAAAA,YAA6C,CAACC,OAAOC,iBAAiB;AAAA,MAAA;AACnF,QAAM,EAAA,YAAcC,eAAH,QAAGA,eAAH,SAAA,UAAA,uBAAGA,WAAYC,cAAf,QAAA,yBAAA,SAAA,SAAG,qBAAsBC,MAAM,GAAGC,YAAH,IAAmBL;AACnE,SAAOM,YACHC,iCAAAA,QAASC,aAAa,kCAAAC,eAAC,0CAAU,KAAX,SAAA,CAAA,GAAmBJ,aAD7C;IAC0D,KAAKJ;GAArC,CAAA,GAAuDK,SAA7E,IACA;CAJS;;;;;AGVR,SAASI,0CACdC,cACAC,SACA;AACA,aAAOC,cAAAA,YAAiB,CAACC,OAAwBC,UAA4C;AAC3F,UAAMC,YAAaJ,QAAQE,KAAD,EAAgBC,KAAxB;AAClB,WAAOC,cAAP,QAAOA,cAAP,SAAOA,YAAaF;KACnBH,YAHI;;ADJT,IAAMM,4CAAqCC,CAAAA,UAAU;AACnD,QAAM,EAZR,SAAA,SAYmBC,IAAaD;AAC9B,QAAME,WAAWC,kCAAYC,OAAD;AAE5B,QAAMC,QACJ,OAAOJ,aAAa,aAChBA,SAAS;IAAEG,SAASF,SAASI;GAArB,IACRX,cAAAA,SAAeY,KAAKN,QAApB;AAGN,QAAMO,MAAMC,0CAAgBP,SAASM,KAAMH,MAAcG,GAA9B;AAC3B,QAAME,aAAa,OAAOT,aAAa;AACvC,SAAOS,cAAcR,SAASI,YAAYX,kCAAAA,cAAmBU,OAAO;IAvBtE;GAuB4C,IAAqC;;AAGjFN,0CAASY,cAAc;AAMvB,SAASR,kCAAYC,SAAkB;AACrC,QAAM,CAACQ,OAAMC,OAAP,QAAkBlB,cAAAA,UAAA;AACxB,QAAMmB,gBAAYnB,cAAAA,QAAkC,CAAA,CAAlC;AAClB,QAAMoB,qBAAiBpB,cAAAA,QAAaS,OAAb;AACvB,QAAMY,2BAAuBrB,cAAAA,QAAqB,MAArB;AAC7B,QAAMF,eAAeW,UAAU,YAAY;AAC3C,QAAM,CAACR,OAAOqB,IAAR,IAAgBzB,0CAAgBC,cAAc;IAClDyB,SAAS;MACPC,SAAS;MACTC,eAAe;;IAEjBC,kBAAkB;MAChBC,OAAO;MACPC,eAAe;;IAEjBC,WAAW;MACTF,OAAO;;GAV0B;AAcrC3B,oBAAAA,WAAgB,MAAM;AACpB,UAAM8B,uBAAuBC,uCAAiBZ,UAAUa,OAAX;AAC7CX,yBAAqBW,UAAU/B,UAAU,YAAY6B,uBAAuB;KAC3E;IAAC7B;GAHJ;AAKAgC,4CAAgB,MAAM;AACpB,UAAMC,SAASf,UAAUa;AACzB,UAAMG,aAAaf,eAAeY;AAClC,UAAMI,oBAAoBD,eAAe1B;AAEzC,QAAI2B,mBAAmB;AACrB,YAAMC,oBAAoBhB,qBAAqBW;AAC/C,YAAMF,uBAAuBC,uCAAiBG,MAAD;AAE7C,UAAIzB;AACFa,aAAK,OAAD;eACKQ,yBAAyB,WAAUI,WAAM,QAANA,WAAM,SAAN,SAAAA,OAAQI,aAAY;AAGhEhB,aAAK,SAAD;WACC;AAOL,cAAMiB,cAAcF,sBAAsBP;AAE1C,YAAIK,cAAcI;AAChBjB,eAAK,eAAD;;AAEJA,eAAK,SAAD;;AAIRF,qBAAeY,UAAUvB;;KAE1B;IAACA;IAASa;GAjCE;AAmCfW,4CAAgB,MAAM;AACpB,QAAIhB,OAAM;AAMR,YAAMuB,qBAAsBtC,CAAAA,UAA0B;AACpD,cAAM4B,uBAAuBC,uCAAiBZ,UAAUa,OAAX;AAC7C,cAAMS,qBAAqBX,qBAAqBY,SAASxC,MAAMyC,aAApC;AAC3B,YAAIzC,MAAM0C,WAAW3B,SAAQwB;AAI3BI,gCAAAA;YAAmB,MAAMvB,KAAK,eAAD;UAA7B;;AAGJ,YAAMwB,uBAAwB5C,CAAAA,UAA0B;AACtD,YAAIA,MAAM0C,WAAW3B;AAEnBI,+BAAqBW,UAAUD,uCAAiBZ,UAAUa,OAAX;;AAGnDf,YAAK8B,iBAAiB,kBAAkBD,oBAAxC;AACA7B,YAAK8B,iBAAiB,mBAAmBP,kBAAzC;AACAvB,YAAK8B,iBAAiB,gBAAgBP,kBAAtC;AACA,aAAO,MAAM;AACXvB,cAAK+B,oBAAoB,kBAAkBF,oBAA3C;AACA7B,cAAK+B,oBAAoB,mBAAmBR,kBAA5C;AACAvB,cAAK+B,oBAAoB,gBAAgBR,kBAAzC;;;AAKFlB,WAAK,eAAD;KAEL;IAACL;IAAMK;GApCK;AAsCf,SAAO;IACLX,WAAW;MAAC;MAAW;MAAoB+B,SAASzC,KAAzC;IACXY,SAAKb,cAAAA,aAAmBiB,CAAAA,SAAsB;AAC5C,UAAIA;AAAME,kBAAUa,UAAUiB,iBAAiBhC,IAAD;AAC9CC,cAAQD,IAAD;OACN,CAAA,CAHE;;;AAST,SAASc,uCAAiBG,QAA8B;AACtD,UAAOA,WAAM,QAANA,WAAM,SAAN,SAAAA,OAAQS,kBAAiB;;",
  "names": ["CONTEXT_UPDATE", "POINTER_DOWN_OUTSIDE", "FOCUS_OUTSIDE", "originalBodyPointerEvents", "DismissableLayerContext", "React", "layers", "Set", "layersWithOutsidePointerEventsDisabled", "branches", "DismissableLayer", "props", "forwardedRef", "layerProps", "context", "node", "setNode", "ownerDocument", "globalThis", "document", "force", "composedRefs", "useComposedRefs", "Array", "from", "highestLayerWithOutsidePointerEventsDisabled", "slice", "highestLayerWithOutsidePointerEventsDisabledIndex", "indexOf", "index", "isBodyPointerEventsDisabled", "size", "isPointerEventsEnabled", "pointerDownOutside", "usePointerDownOutside", "event", "target", "isPointerDownOnBranch", "some", "branch", "contains", "onPointerDownOutside", "onInteractOutside", "defaultPrevented", "onDismiss", "focusOutside", "useFocusOutside", "isFocusInBranch", "onFocusOutside", "useEscapeKeydown", "isHighestLayer", "onEscapeKeyDown", "preventDefault", "disableOutsidePointerEvents", "body", "style", "pointerEvents", "add", "dispatchUpdate", "delete", "handleUpdate", "addEventListener", "removeEventListener", "$kqwpH$createElement", "undefined", "composeEventHandlers", "onFocusCapture", "onBlurCapture", "onPointerDownCapture", "usePointerDownOutside", "onPointerDownOutside", "ownerDocument", "globalThis", "document", "handlePointerDownOutside", "useCallbackRef", "isPointerInsideReactTreeRef", "React", "handleClickRef", "handlePointerDown", "event", "target", "current", "handleAndDispatchPointerDownOutsideEvent", "handleAndDispatchCustomEvent", "POINTER_DOWN_OUTSIDE", "eventDetail", "discrete", "originalEvent", "pointerType", "removeEventListener", "addEventListener", "once", "timerId", "window", "setTimeout", "clearTimeout", "onPointerDownCapture", "useFocusOutside", "onFocusOutside", "handleFocusOutside", "isFocusInsideReactTreeRef", "handleFocus", "FOCUS_OUTSIDE", "onFocusCapture", "onBlurCapture", "dispatchUpdate", "CustomEvent", "CONTEXT_UPDATE", "dispatchEvent", "name", "handler", "detail", "bubbles", "cancelable", "dispatchDiscreteCustomEvent", "AUTOFOCUS_ON_MOUNT", "AUTOFOCUS_ON_UNMOUNT", "EVENT_OPTIONS", "bubbles", "cancelable", "FocusScope", "React", "props", "forwardedRef", "onMountAutoFocus", "onMountAutoFocusProp", "onUnmountAutoFocus", "onUnmountAutoFocusProp", "scopeProps", "container", "setContainer", "useCallbackRef", "lastFocusedElementRef", "composedRefs", "useComposedRefs", "node", "focusScope", "paused", "pause", "resume", "current", "trapped", "handleFocusIn", "event", "target", "contains", "focus", "select", "handleFocusOut", "relatedTarget", "handleMutations", "mutations", "focusedElement", "document", "activeElement", "body", "mutation", "removedNodes", "length", "addEventListener", "mutationObserver", "MutationObserver", "observe", "childList", "subtree", "removeEventListener", "disconnect", "focusScopesStack", "add", "previouslyFocusedElement", "hasFocusedCandidate", "mountEvent", "CustomEvent", "AUTOFOCUS_ON_MOUNT", "EVENT_OPTIONS", "dispatchEvent", "defaultPrevented", "focusFirst", "removeLinks", "getTabbableCandidates", "setTimeout", "unmountEvent", "AUTOFOCUS_ON_UNMOUNT", "remove", "handleKeyDown", "loop", "isTabKey", "key", "altKey", "ctrlKey", "metaKey", "currentTarget", "first", "last", "getTabbableEdges", "hasTabbableElementsInside", "preventDefault", "shiftKey", "$45QHv$createElement", "focusFirst", "candidates", "select", "previouslyFocusedElement", "document", "activeElement", "candidate", "focus", "getTabbableEdges", "container", "getTabbableCandidates", "first", "findVisible", "last", "reverse", "nodes", "walker", "createTreeWalker", "NodeFilter", "SHOW_ELEMENT", "acceptNode", "node", "isHiddenInput", "tagName", "type", "disabled", "hidden", "FILTER_SKIP", "tabIndex", "FILTER_ACCEPT", "nextNode", "push", "currentNode", "elements", "element", "isHidden", "upTo", "getComputedStyle", "visibility", "undefined", "display", "parentElement", "isSelectableInput", "HTMLInputElement", "preventScroll", "focusScopesStack", "createFocusScopesStack", "stack", "add", "focusScope", "activeFocusScope", "pause", "arrayRemove", "unshift", "remove", "resume", "array", "item", "updatedArray", "index", "indexOf", "splice", "removeLinks", "items", "filter", "Portal", "React", "props", "forwardedRef", "globalThis", "document", "body", "portalProps", "container", "ReactDOM", "createPortal", "$7SXl2$createElement", "useStateMachine", "initialState", "machine", "React", "state", "event", "nextState", "Presence", "props", "children", "presence", "usePresence", "present", "child", "isPresent", "only", "ref", "useComposedRefs", "forceMount", "displayName", "node", "setNode", "stylesRef", "prevPresentRef", "prevAnimationNameRef", "send", "mounted", "UNMOUNT", "ANIMATION_OUT", "unmountSuspended", "MOUNT", "ANIMATION_END", "unmounted", "currentAnimationName", "getAnimationName", "current", "useLayoutEffect", "styles", "wasPresent", "hasPresentChanged", "prevAnimationName", "display", "isAnimating", "handleAnimationEnd", "isCurrentAnimation", "includes", "animationName", "target", "ReactDOM", "handleAnimationStart", "addEventListener", "removeEventListener", "getComputedStyle"]
}
